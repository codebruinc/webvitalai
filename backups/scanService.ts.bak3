import { createClient } from '@supabase/supabase-js';
import { v4 as uuidv4 } from 'uuid';
import { Queue } from 'bullmq';
import { createQueue } from './queueService';
import { Database } from '@/types/supabase';

// Initialize Supabase clients
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
const supabaseServiceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;

// Create a client with the service role key for admin operations
const serviceRoleClient = createClient<Database>(supabaseUrl, supabaseServiceRoleKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  }
});

// Create a client with the anonymous key for public operations
const anonClient = createClient<Database>(supabaseUrl, supabaseAnonKey);

// Log initialization for debugging
console.log('Supabase clients initialized:', {
  hasServiceRoleKey: !!supabaseServiceRoleKey,
  hasAnonKey: !!supabaseAnonKey,
  supabaseUrl,
  clientType: 'server',
  serviceRoleClientType: 'service-role'
});

// Queue for processing scans
let scanQueue: Queue;

// Initialize the queue
try {
  scanQueue = createQueue('scan-queue');
} catch (error) {
  console.error('Error initializing scan queue:', error);
}

/**
 * Initiates a website scan
 * @param url The URL to scan
 * @param userId The user ID (optional)
 * @param isTestingMode Whether to use test data (default: false)
 * @returns The scan ID
 */
export async function initiateScan(
  url: string,
  userId?: string,
  isTestingMode: boolean = process.env.TESTING_MODE === 'true'
) {
  console.log('initiateScan: Starting scan creation with service role client', {
    url,
    userId,
  });

  try {
    // Always use the service role client for database operations to bypass RLS
    const supabase = serviceRoleClient;
    
    // If userId is provided, verify the user exists
    if (userId) {
      const { data: user, error: userError } = await supabase
        .from('users')
        .select('id')
        .eq('id', userId)
        .single();

      if (userError) {
        // Try to find the user in auth.users table
        const { data: authUser, error: authUserError } = await supabase
          .from('auth.users')
          .select('id')
          .eq('id', userId)
          .single();

        if (authUserError) {
          console.error('User not found in either table:', userError, authUserError);
        } else {
          console.log(`User found in auth.users table: ${userId}`);
        }
      } else {
        console.log(`User found in public.users table: ${userId}`);
      }
    }

    // Find or create website
    let websiteId: string;
    const { data: existingWebsite, error: websiteError } = await supabase
      .from('websites')
      .select('id')
      .eq('url', url)
      .maybeSingle();

    if (websiteError) {
      console.error('Error finding website:', websiteError);
      throw new Error(`Failed to find website: ${websiteError.message}`);
    }

    if (existingWebsite) {
      websiteId = existingWebsite.id;
    } else {
      // Create a new website
      const { data: newWebsite, error: createError } = await supabase
        .from('websites')
        .insert({
          url,
          user_id: userId,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .select('id')
        .single();

      if (createError) {
        console.error('Error creating website:', createError);
        throw new Error(`Failed to create website: ${createError.message}`);
      }

      websiteId = newWebsite.id;
    }

    // Create a new scan
    console.log('Creating scan with service role client');
    const scanId = uuidv4();
    const { data: scan, error: scanError } = await supabase
      .from('scans')
      .insert({
        id: scanId,
        website_id: websiteId,
        status: 'pending',
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .select('id')
      .single();

    if (scanError) {
      console.error('Error creating scan:', scanError);
      throw new Error(`Failed to create scan: ${scanError.message}`);
    }

    console.log(`Scan created successfully: ${scan.id}`);

    // Add the scan to the queue for processing
    if (!isTestingMode) {
      await scanQueue.add(
        'process-scan',
        {
          scanId: scan.id,
          url,
          userId
        },
        {
          removeOnComplete: true,
          removeOnFail: 1000
        }
      );
    }

    return scan.id;
  } catch (error) {
    console.error('Error initiating scan:', error);
    throw error;
  }
}

/**
 * Gets the status of a scan
 * @param scanId The scan ID
 * @returns The scan status
 */
export async function getScanStatus(scanId: string) {
  try {
    // Always use the service role client for database operations to bypass RLS
    const supabase = serviceRoleClient;
    
    const { data, error } = await supabase
      .from('scans')
      .select('*')
      .eq('id', scanId)
      .single();

    if (error) {
      console.error('Error fetching scan:', error);
      throw new Error(`Failed to fetch scan: ${error.message}`);
    }

    return data;
  } catch (error) {
    console.error('Error getting scan status:', error);
    throw error;
  }
}

/**
 * Gets the results of a scan
 * @param scanId The scan ID
 * @returns The scan results
 */
export async function getScanResults(scanId: string) {
  try {
    // Always use the service role client for database operations to bypass RLS
    const supabase = serviceRoleClient;
    
    // Get the scan
    const { data: scan, error: scanError } = await supabase
      .from('scans')
      .select('*')
      .eq('id', scanId)
      .single();

    if (scanError) {
      console.error('Error fetching scan:', scanError);
      throw new Error(`Failed to fetch scan: ${scanError.message}`);
    }

    // Get the metrics
    const { data: metrics, error: metricsError } = await supabase
      .from('metrics')
      .select('*')
      .eq('scan_id', scanId);

    if (metricsError) {
      console.error('Error fetching metrics:', metricsError);
      throw new Error(`Failed to fetch metrics: ${metricsError.message}`);
    }

    // Get the issues
    const { data: issues, error: issuesError } = await supabase
      .from('issues')
      .select('*')
      .eq('scan_id', scanId);

    if (issuesError) {
      console.error('Error fetching issues:', issuesError);
      throw new Error(`Failed to fetch issues: ${issuesError.message}`);
    }

    return {
      scan,
      metrics,
      issues
    };
  } catch (error) {
    console.error('Error getting scan results:', error);
    throw error;
  }
}

/**
 * Updates the status of a scan
 * @param scanId The scan ID
 * @param status The new status
 */
export async function updateScanStatus(scanId: string, status: string) {
  try {
    // Always use the service role client for database operations to bypass RLS
    const supabase = serviceRoleClient;
    
    const { error } = await supabase
      .from('scans')
      .update({
        status,
        updated_at: new Date().toISOString()
      })
      .eq('id', scanId);

    if (error) {
      console.error('Error updating scan status:', error);
      throw new Error(`Failed to update scan status: ${error.message}`);
    }
  } catch (error) {
    console.error('Error updating scan status:', error);
    throw error;
  }
}

/**
 * Stores metrics for a scan
 * @param scanId The scan ID
 * @param metrics The metrics to store
 */
export async function storeMetrics(scanId: string, metrics: any[]) {
  try {
    // Always use the service role client for database operations to bypass RLS
    const supabase = serviceRoleClient;
    
    // Format the metrics
    const formattedMetrics = metrics.map(metric => ({
      scan_id: scanId,
      name: metric.name,
      value: metric.value,
      category: metric.category,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    }));

    // Insert the metrics
    const { error } = await supabase
      .from('metrics')
      .insert(formattedMetrics);

    if (error) {
      console.error('Failed to store metrics:', error);
      throw new Error(`Failed to store metrics: ${error.message}`);
    }
  } catch (error) {
    console.error('Error storing metrics:', error);
    throw error;
  }
}

/**
 * Stores issues for a scan
 * @param scanId The scan ID
 * @param issues The issues to store
 */
export async function storeIssues(scanId: string, issues: any[]) {
  try {
    // Always use the service role client for database operations to bypass RLS
    const supabase = serviceRoleClient;
    
    // Format the issues
    const formattedIssues = issues.map(issue => ({
      scan_id: scanId,
      title: issue.title,
      description: issue.description,
      severity: issue.severity,
      category: issue.category,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    }));

    // Insert the issues
    const { error } = await supabase
      .from('issues')
      .insert(formattedIssues);

    if (error) {
      console.error('Failed to store issues:', error);
      throw new Error(`Failed to store issues: ${error.message}`);
    }
  } catch (error) {
    console.error('Error storing issues:', error);
    throw error;
  }
}

/**
 * Gets the user ID associated with a scan
 * @param scanId The scan ID
 * @returns The user ID
 */
export async function getScanUserId(scanId: string) {
  try {
    // Always use the service role client for database operations to bypass RLS
    const supabase = serviceRoleClient;
    
    const { data, error } = await supabase
      .from('scans')
      .select('websites:website_id(user_id)')
      .eq('id', scanId)
      .single();

    if (error) {
      console.error('Error fetching scan user ID:', error);
      return null;
    }

    if (!data || !data.websites) {
      console.log('No user ID found for scan:', scanId);
      return null;
    }

    return data.websites.user_id;
  } catch (error) {
    console.error('Error getting scan user ID:', error);
    return null;
  }
}

// Add the missing getScanResult function that's being imported in route.ts
// This is a wrapper around the existing getScanResults function

import { createClient } from '@supabase/supabase-js';
import { Database } from '@/types/supabase';

// Initialize Supabase clients
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseServiceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;

// Create a client with the service role key for admin operations
const serviceRoleClient = createClient<Database>(supabaseUrl, supabaseServiceRoleKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  }
});

// Store mock scan URLs for testing mode
export const mockScanUrls = new Map<string, string>();

/**
 * Get a scan result - this is the missing function that's imported in route.ts
 * @param scanId The scan ID
 * @returns The scan result
 */
export async function getScanResult(scanId: string) {
  try {
    // Check if we're in testing mode based on environment variables
    const isTestingMode = process.env.NODE_ENV === 'development' || process.env.TESTING_MODE === 'true';
    
    // If we're in testing mode and have a mock URL, return mock data
    if (isTestingMode && mockScanUrls.has(scanId)) {
      const mockUrl = mockScanUrls.get(scanId) || 'https://example.com';
      
      return {
        id: scanId,
        url: mockUrl,
        status: 'completed',
        performance: {
          score: 85,
          metrics: {
            'First Contentful Paint': { value: 1.2, unit: 's' },
            'Largest Contentful Paint': { value: 2.5, unit: 's' },
            'Total Blocking Time': { value: 150, unit: 'ms' },
            'Cumulative Layout Shift': { value: 0.05 }
          }
        },
        accessibility: {
          score: 92,
          issues: [
            { title: 'Images must have alternate text', description: 'Provide alt text for images', severity: 'medium' }
          ]
        },
        seo: {
          score: 88,
          issues: [
            { title: 'Document does not have a meta description', description: 'Add a meta description', severity: 'medium' }
          ]
        },
        bestPractices: {
          score: 90,
          issues: []
        },
        security: {
          score: 75,
          grade: 'B',
          issues: [
            { title: 'Missing Content-Security-Policy header', description: 'Add CSP header', severity: 'high' }
          ]
        },
        recommendations: [
          {
            issueId: 'rec-1',
            description: 'Optimize images to improve load time',
            priority: 'high',
            implementationDetails: 'Use WebP format and compress images',
            impact: 8,
            effort: 3,
            priorityScore: 8.5
          },
          {
            issueId: 'rec-2',
            description: 'Add alt text to all images',
            priority: 'medium',
            implementationDetails: 'Ensure all <img> tags have descriptive alt attributes',
            impact: 6,
            effort: 2,
            priorityScore: 7.0
          }
        ]
      };
    }
    
    // Get scan data from the database
    const { data: scan, error: scanError } = await serviceRoleClient
      .from('scans')
      .select('id, status, error, completed_at, website_id, websites(url)')
      .eq('id', scanId)
      .single();
    
    if (scanError || !scan) {
      console.error('Failed to get scan result:', scanError);
      return null;
    }
    
    // Get metrics
    const { data: metrics, error: metricsError } = await serviceRoleClient
      .from('metrics')
      .select('name, value, unit, category')
      .eq('scan_id', scanId);
    
    if (metricsError) {
      console.error('Failed to get metrics:', metricsError);
    }
    
    // Get issues
    const { data: issues, error: issuesError } = await serviceRoleClient
      .from('issues')
      .select('id, title, description, severity, category')
      .eq('scan_id', scanId);
    
    if (issuesError) {
      console.error('Failed to get issues:', issuesError);
    }
    
    // Get recommendations
    const { data: recommendations, error: recommendationsError } = await serviceRoleClient
      .from('recommendations')
      .select('issue_id, description, priority, implementation_details, impact, effort, priority_score')
      .in(
        'issue_id',
        issues?.map(issue => issue.id) || []
      )
      .order('priority_score', { ascending: false });
    
    if (recommendationsError) {
      console.error('Failed to get recommendations:', recommendationsError);
    }
    
    // Prepare the scan result
    const url = (scan.websites as any).url;
    const result = {
      id: scanId,
      url,
      status: scan.status === 'completed' ? 'completed' : 'failed',
      error: scan.error || undefined,
    };
    
    // Process metrics and issues to build the full result
    // This is a simplified version - in production you would need to process all the data
    
    return result;
  } catch (error) {
    console.error('Failed to get scan result:', error);
    return null;
  }
}